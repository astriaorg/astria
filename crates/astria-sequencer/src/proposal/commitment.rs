use std::{
    collections::HashMap,
    sync::Arc,
};

use astria_core::{
    primitive::v1::RollupId,
    protocol::group_rollup_data_submissions_in_signed_transaction_transactions_by_rollup_id,
    sequencerblock::v1::block::{
        DataItem,
        Deposit,
        RollupData,
    },
};
use bytes::Bytes;

use crate::checked_transaction::CheckedTransaction;

/// Wrapper for values returned by [`generate_rollup_datas_commitment`].
// NOTE: The generic arg can be removed when we no longer support running a network where the raw
//       txs are not encoded `DataItem`s, i.e. after `Aspen`. This is not needed for syncing to a
//       network with such legacy blocks, since it's only used via prepare-/process-proposal.
pub(crate) struct GeneratedCommitments<const USES_DATA_ITEM_ENUM: bool> {
    pub(crate) rollup_datas_root: [u8; 32],
    pub(crate) rollup_ids_root: [u8; 32],
}

impl<const USES_DATA_ITEM_ENUM: bool> GeneratedCommitments<USES_DATA_ITEM_ENUM> {
    /// The total size of the commitments, encoded as `DataItem`s in bytes if `USES_DATA_ITEM_ENUM`
    /// is true, or not encoded if false.
    pub(crate) fn total_size() -> usize {
        if USES_DATA_ITEM_ENUM {
            DataItem::ENCODED_ROLLUP_TRANSACTIONS_ROOT_LENGTH
                + DataItem::ENCODED_ROLLUP_IDS_ROOT_LENGTH
        } else {
            64
        }
    }
}

impl<const USES_DATA_ITEM_ENUM: bool> IntoIterator for GeneratedCommitments<USES_DATA_ITEM_ENUM> {
    type IntoIter = std::array::IntoIter<Self::Item, 2>;
    type Item = Bytes;

    fn into_iter(self) -> Self::IntoIter {
        if USES_DATA_ITEM_ENUM {
            let rollup_datas_root =
                DataItem::RollupTransactionsRoot(self.rollup_datas_root).encode();
            let rollup_ids_root = DataItem::RollupIdsRoot(self.rollup_ids_root).encode();
            [rollup_datas_root, rollup_ids_root].into_iter()
        } else {
            [
                self.rollup_datas_root.to_vec().into(),
                self.rollup_ids_root.to_vec().into(),
            ]
            .into_iter()
        }
    }
}

/// Called when we receive a `PrepareProposal` or `ProcessProposal` consensus message.
///
/// In the case of `PrepareProposal`, we use this function to generate the `rollup_datas_commitment`
/// to be placed at the start of the block.
///
/// In the case of `ProcessProposal`, we use this function to generate and verify the
/// `rollup_datas_commitment` expected at the start of the block.
///
/// This function sorts the block's `sequence::Action`s contained within the transactions
/// using their `rollup_id`. It also appends the `Deposit`s generated by the block execution
/// to each rollup's sequenced data.
/// It then returns the merkle root of the tree where each leaf is
/// a commitment of the rollup data (`sequence::Action`s and `Deposit`s) with the same `rollup_id`.
/// The leaves are ordered by `rollup_id` in ascending order.
///
/// The leaf, which contains a commitment to every action with the same `rollup_id`, is currently
/// implemented as ( `rollup_id` || root of merkle tree of the `sequence::Action`s ).
/// This is somewhat arbitrary, but could be useful for proof of an action within the rollup datas
/// tree.
pub(crate) fn generate_rollup_datas_commitment<const USES_DATA_ITEM_ENUM: bool>(
    checked_txs: &[Arc<CheckedTransaction>],
    deposits: HashMap<RollupId, Vec<Deposit>>,
) -> GeneratedCommitments<USES_DATA_ITEM_ENUM> {
    use prost::Message as _;

    let rollup_data_bytes = checked_txs
        .iter()
        .flat_map(|checked_tx| checked_tx.rollup_data_bytes());
    let mut rollup_ids_to_txs =
        group_rollup_data_submissions_in_signed_transaction_transactions_by_rollup_id(
            rollup_data_bytes,
        );

    for (rollup_id, deposit) in deposits {
        rollup_ids_to_txs
            .entry(rollup_id)
            .or_default()
            .extend(deposit.into_iter().map(|deposit| {
                RollupData::Deposit(Box::new(deposit))
                    .into_raw()
                    .encode_to_vec()
                    .into()
            }));
    }

    rollup_ids_to_txs.sort_unstable_keys();
    let rollup_ids_root = merkle::Tree::from_leaves(rollup_ids_to_txs.keys()).root();

    // each leaf of the action tree is the root of a merkle tree of the `sequence::Action`s
    // with the same `rollup_id`, prepended with `rollup_id`.
    // the leaves are sorted in ascending order by `rollup_id`.
    let rollup_datas_root =
        astria_core::primitive::v1::derive_merkle_tree_from_rollup_txs(&rollup_ids_to_txs).root();

    GeneratedCommitments {
        rollup_datas_root,
        rollup_ids_root,
    }
}

#[cfg(test)]
mod tests {
    use astria_core::protocol::transaction::v1::action::{
        RollupDataSubmission,
        Transfer,
    };
    use bytes::Bytes;

    use super::*;
    use crate::test_utils::{
        astria_address,
        nria,
        Fixture,
        ALICE,
        BOB,
    };

    #[tokio::test]
    async fn generate_rollup_datas_commitment_should_ignore_transfers() {
        let fixture = Fixture::default_initialized().await;

        let rollup_data_submission = RollupDataSubmission {
            rollup_id: RollupId::from_unhashed_bytes(b"testchainid"),
            data: Bytes::from_static(b"hello world"),
            fee_asset: nria().into(),
        };
        let transfer_action = Transfer {
            to: astria_address(&[0u8; 20]),
            amount: 1,
            asset: nria().into(),
            fee_asset: nria().into(),
        };

        let tx = fixture
            .checked_tx_builder()
            .with_action(rollup_data_submission.clone())
            .with_action(transfer_action)
            .with_signer(ALICE.clone())
            .build()
            .await;

        let GeneratedCommitments {
            rollup_datas_root: commitment_0,
            ..
        } = generate_rollup_datas_commitment::<false>(&[tx], HashMap::new());

        let tx = fixture
            .checked_tx_builder()
            .with_action(rollup_data_submission.clone())
            .with_signer(BOB.clone())
            .build()
            .await;

        let GeneratedCommitments {
            rollup_datas_root: commitment_1,
            ..
        } = generate_rollup_datas_commitment::<false>(&[tx], HashMap::new());
        assert_eq!(commitment_0, commitment_1);
    }

    #[tokio::test]
    // TODO(https://github.com/astriaorg/astria/issues/312): ensure this test is stable
    // against changes in the serialization format (protobuf is not deterministic)
    async fn generate_rollup_datas_commitment_snapshot() {
        let fixture = Fixture::default_initialized().await;
        // this tests that the commitment generated is what is expected via a test vector.
        // this test will only break in the case of a breaking change to the commitment scheme,
        // thus if this test needs to be updated, we should cut a new release.

        let rollup_data_submission = RollupDataSubmission {
            rollup_id: RollupId::from_unhashed_bytes(b"testchainid"),
            data: b"helloworld".to_vec().into(),
            fee_asset: nria().into(),
        };
        let transfer_action = Transfer {
            to: astria_address(&[0u8; 20]),
            amount: 1,
            asset: nria().into(),
            fee_asset: nria().into(),
        };

        let tx = fixture
            .checked_tx_builder()
            .with_action(rollup_data_submission.clone())
            .with_action(transfer_action)
            .with_signer(ALICE.clone())
            .build()
            .await;

        let GeneratedCommitments {
            rollup_datas_root: actual,
            ..
        } = generate_rollup_datas_commitment::<false>(&[tx], HashMap::new());

        let expected = [
            189_u8, 156, 127, 228, 51, 249, 64, 237, 150, 91, 219, 216, 1, 99, 135, 28, 235, 15,
            249, 129, 3, 59, 231, 75, 92, 72, 103, 106, 173, 167, 251, 238,
        ];
        assert_eq!(expected, actual);
    }
}
