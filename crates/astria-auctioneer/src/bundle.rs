use std::{
    num::NonZeroU64,
    sync::OnceLock,
};

// use alloy_consensus::transaction::Recovered;
use alloy_consensus::TxEnvelope;
use alloy_eips::Decodable2718 as _;
use alloy_primitives::{
    Keccak256,
    B256,
};
use alloy_rpc_types_eth::TransactionRequest;
use indexmap::IndexSet;
use uuid::Uuid;

/// Guarantees to only contain legacy, EIP2930, EIP1559, or EIP4844 transactions.
///
/// Flame rejects EIP7702 and also Astria deposit (tagged 0x5a) transactions.
// TODO: At this point I am not sure if it's necessary to use a signer-recovered transaction,
// i.e. [`alloy_consensus::transaction::RecoveredTx`], or just a plain [`TxEnvelope`].
//
// rbuilder itself makes use of the signer in the recovered tx to check the signer against
// blocklists, fetching signer nonces when recovering/reporting errors (e.g. nonce too high).
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) struct Transaction(TxEnvelope);

impl Transaction {
    pub(crate) fn decode_2718(mut buf: &[u8]) -> Result<Self, TransactionDecode2718Error> {
        let buf = &mut buf;
        let inner: TxEnvelope = match TxEnvelope::extract_type_byte(buf) {
            Some(0x1 | 0x2 | 0x3) | None => TxEnvelope::decode_2718(buf).map_err(|source| {
                TransactionDecode2718Error::Decode2718 {
                    source,
                }
            })?,
            Some(tag) => {
                return Err(TransactionDecode2718Error::Unsupported {
                    tag,
                })
            }
        };
        Ok(Self(inner))
    }

    pub(crate) fn hash(&self) -> &B256 {
        self.0.hash()
    }

    /// Converts the transaction to a eth rpc transaction request.
    pub(crate) fn to_transaction_request(&self) -> TransactionRequest {
        self.0.clone().into()
    }
}

#[derive(thiserror::Error, Debug)]
pub(crate) enum TransactionDecode2718Error {
    #[error("failed decoding RLP")]
    Decode2718 {
        source: alloy_eips::eip2718::Eip2718Error,
    },
    #[error(
        "received transaction with unsupported tag `{tag:0x}`; only untagged legacy, EIP2930 0x1, \
         EIP1559 0x2, and EIP4844 0x3 transactions are supported"
    )]
    Unsupported { tag: u8 },
}

/// Bundle sent to us usually by a searcher via eth_sendBundle (https://docs.flashbots.net/flashbots-auction/advanced/rpc-endpoint#eth_sendbundle).
#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct Bundle {
    /// None means in the first possible block.
    txs: Vec<Transaction>,
    raw_txs: Vec<alloy_primitives::Bytes>,
    block: Option<NonZeroU64>,
    /// A list of tx hashes that are allowed to revert.
    reverting_tx_hashes: IndexSet<B256, gxhash::GxBuildHasher>,
    /// A list of tx hashes that are allowed to be discarded, but may not revert on chain.
    dropping_tx_hashes: IndexSet<B256, gxhash::GxBuildHasher>,
    /// Virtual hash generated by concatenating all txs hashes (+some more info) and hashing them.
    /// See [Bundle::hash_slow] for more details.
    hash: OnceLock<B256>,
    /// Unique id we generate.
    uuid: Uuid,
    /// The timestamp when this bundle was first constructed,i.e. seen by the orderpool.
    timestamp: jiff::Timestamp,
}

impl Bundle {
    /// Instantiates a [`Bundle`] with empty fields or fields set to their default.
    pub(crate) fn new() -> Self {
        Self {
            raw_txs: vec![],
            txs: vec![],
            block: None,
            reverting_tx_hashes: IndexSet::with_hasher(gxhash::GxBuildHasher::default()),
            dropping_tx_hashes: IndexSet::with_hasher(gxhash::GxBuildHasher::default()),
            hash: OnceLock::new(),
            uuid: Uuid::nil(),
            timestamp: jiff::Timestamp::now(),
        }
    }

    pub(crate) fn set_raw_txs(&mut self, raw_txs: Vec<alloy_primitives::Bytes>) -> &mut Self {
        self.raw_txs = raw_txs;
        self
    }

    /// Sets the bundle's transactions to `txs`.
    pub(crate) fn set_txs(&mut self, txs: Vec<Transaction>) -> &mut Self {
        self.txs = txs;
        let _ = self.hash.take();
        self
    }

    pub(crate) fn set_block(&mut self, block: Option<NonZeroU64>) -> &mut Self {
        self.block = block;
        self
    }

    pub(crate) fn collect_reverting_tx_hashes(
        &mut self,
        reverting_tx_hashes: impl IntoIterator<Item = B256>,
    ) -> &mut Self {
        self.reverting_tx_hashes.clear();
        self.reverting_tx_hashes.extend(reverting_tx_hashes);
        self
    }

    pub(crate) fn collect_dropping_tx_hashes(
        &mut self,
        dropping_tx_hashes: impl IntoIterator<Item = B256>,
    ) -> &mut Self {
        self.dropping_tx_hashes.clear();
        self.dropping_tx_hashes.extend(dropping_tx_hashes);
        self
    }

    pub(crate) fn set_uuid(&mut self, uuid: Uuid) -> &mut Self {
        self.uuid = uuid;
        self
    }

    pub(crate) fn hash(&self) -> &B256 {
        self.hash.get_or_init(|| {
            let mut hasher = Keccak256::new();
            for tx in &self.txs {
                hasher.update(tx.hash())
            }
            hasher.finalize()
        })
    }

    pub(crate) fn is_dropping(&self, tx_hash: &B256) -> bool {
        self.dropping_tx_hashes.contains(tx_hash)
    }

    pub(crate) fn is_reverting(&self, tx_hash: &B256) -> bool {
        self.reverting_tx_hashes.contains(tx_hash)
    }

    pub(crate) fn timestamp(&self) -> &jiff::Timestamp {
        &self.timestamp
    }

    pub(crate) fn txs(&self) -> &[Transaction] {
        &self.txs
    }

    pub(crate) fn uuid(&self) -> &Uuid {
        &self.uuid
    }
}
