use clap::Subcommand;
use color_eyre::eyre::{
    self,
    eyre,
    WrapErr as _,
};
use std::str::FromStr;

use astria_core::protocol::transaction::v1::action::Action;
use astria_sequencer_client::{
    Client as _,
    HttpClient,
    tendermint_rpc,
};

use crate::utils::submit_transaction;

#[derive(Debug, clap::Args)]
pub(crate) struct Command {
    #[command(subcommand)]
    command: SubCommand,
}

impl Command {
    pub(crate) async fn run(self) -> eyre::Result<()> {
        match self.command {
            SubCommand::CreateMarket(create_market) => create_market.run().await,
            SubCommand::CreateOrder(create_order) => create_order.run().await,
            SubCommand::CancelOrder(cancel_order) => cancel_order.run().await,
            SubCommand::GetMarkets(get_markets) => get_markets.run().await,
            SubCommand::GetOrders(get_orders) => get_orders.run().await,
        }
    }
}

/// Interact with the Sequencer orderbook
#[derive(Debug, Subcommand)]
enum SubCommand {
    /// Create a new trading market
    CreateMarket(CreateMarketCommand),
    /// Create a new order
    CreateOrder(CreateOrderCommand),
    /// Cancel an existing order
    CancelOrder(CancelOrderCommand),
    /// Get a list of available markets
    GetMarkets(GetMarketsCommand),
    /// Get orders for a specific market
    GetOrders(GetOrdersCommand),
}

#[derive(Debug, clap::Args)]
struct CreateMarketCommand {
    /// Market identifier, e.g., BTC/USD
    market: String,
    /// Base asset, e.g., BTC
    base_asset: String,
    /// Quote asset, e.g., USD
    quote_asset: String,
    /// Minimum price increment, e.g., 0.01
    tick_size: String,
    /// Minimum quantity increment, e.g., 0.001
    lot_size: String,
    /// Asset to pay fees in
    #[arg(long, default_value = "nria")]
    fee_asset: String,
    /// RPC endpoint
    #[arg(short, long, default_value = "http://localhost:26657")]
    sequencer_url: String,
    /// Chain ID
    #[arg(long, default_value = "astria")]
    chain_id: String,
    /// Prefix for addresses
    #[arg(long, default_value = "astria")]
    prefix: String,
    /// Private key (hex-encoded)
    #[arg(short, long, env = "ASTRIA_CLI_SEQUENCER_PRIVATE_KEY")]
    private_key: String,
}

impl CreateMarketCommand {
    async fn run(self) -> eyre::Result<()> {
        // Constructing the action JSON manually for now
        // This avoids having to deal with complex type conversions
        let action_json = format\!(
            r#"{{
                "createMarket": {{
                    "market": "{}",
                    "base_asset": "{}",
                    "quote_asset": "{}",
                    "tick_size": {{
                        "lo": "{}",
                        "hi": "0"
                    }},
                    "lot_size": {{
                        "lo": "{}",
                        "hi": "0"
                    }},
                    "fee_asset": "{}"
                }}
            }}"#,
            self.market, self.base_asset, self.quote_asset, 
            self.tick_size, self.lot_size, self.fee_asset
        );

        let action: Action = serde_json::from_str(&action_json)
            .wrap_err("failed to construct action from JSON")?;

        // First get a client to check transaction status
        let url = tendermint_rpc::Url::from_str(&self.sequencer_url)
            .wrap_err("failed to parse sequencer URL")?;
        let _sequencer_client = HttpClient::new(url)
            .wrap_err("failed constructing http sequencer client")?;
            
        println\!("Submitting transaction to create market...");
        
        let hash = match submit_transaction(
            &self.sequencer_url,
            self.chain_id,
            &self.prefix,
            &self.private_key,
            action,
        )
        .await {
            Ok(response) => {
                println\!("Transaction submitted successfully\!");
                println\!("Transaction hash: {}", response.hash);
                println\!("Block height: {}", response.height);
                response.hash
            },
            Err(e) => {
                println\!("Transaction submission completed with error: {}", e);
                println\!("The transaction may still have been accepted.");
                println\!("Check the sequencer logs for more information.");
                return Err(e);
            }
        };
        
        // Try to query the transaction status
        println\!("You can query this transaction with:");
        println\!("curl -s '{}/tx?hash=0x{}' | jq", self.sequencer_url, hex::encode(hash.as_bytes()));

        Ok(())
    }
}

#[derive(Debug, clap::Args)]
struct CreateOrderCommand {
    /// Market identifier, e.g., BTC/USD
    market: String,
    /// Order side (BUY or SELL)
    side: String,
    /// Order type (LIMIT or MARKET)
    order_type: String,
    /// Order price (required for limit orders)
    price: String,
    /// Order quantity
    quantity: String,
    /// Time in force (GTC, IOC, or FOK)
    time_in_force: String,
    /// Asset to pay fees in
    #[arg(long, default_value = "nria")]
    fee_asset: String,
    /// RPC endpoint
    #[arg(short, long, default_value = "http://localhost:26657")]
    sequencer_url: String,
    /// Chain ID
    #[arg(long, default_value = "astria")]
    chain_id: String,
    /// Prefix for addresses
    #[arg(long, default_value = "astria")]
    prefix: String,
    /// Private key (hex-encoded)
    #[arg(short, long, env = "ASTRIA_CLI_SEQUENCER_PRIVATE_KEY")]
    private_key: String,
}

impl CreateOrderCommand {
    async fn run(self) -> eyre::Result<()> {
        // Map side string to the expected enum value
        let side_value = match self.side.to_uppercase().as_str() {
            "BUY" => 1,
            "SELL" => 2,
            _ => return Err(eyre\!("Invalid order side. Must be BUY or SELL")),
        };

        // Map order type string to the expected enum value
        let order_type_value = match self.order_type.to_uppercase().as_str() {
            "LIMIT" => 1,
            "MARKET" => 2,
            _ => return Err(eyre\!("Invalid order type. Must be LIMIT or MARKET")),
        };

        // Map time in force string to the expected enum value
        let time_in_force_value = match self.time_in_force.to_uppercase().as_str() {
            "GTC" => 1,
            "IOC" => 2,
            "FOK" => 3,
            _ => return Err(eyre\!("Invalid time in force. Must be GTC, IOC, or FOK")),
        };

        // Constructing the action JSON manually
        let action_json = format\!(
            r#"{{
                "createOrder": {{
                    "market": "{}",
                    "side": {},
                    "type": {},
                    "price": {{
                        "lo": "{}",
                        "hi": "0"
                    }},
                    "quantity": {{
                        "lo": "{}",
                        "hi": "0"
                    }},
                    "time_in_force": {},
                    "fee_asset": "{}"
                }}
            }}"#,
            self.market, side_value, order_type_value, 
            self.price, self.quantity, time_in_force_value, self.fee_asset
        );

        let action: Action = serde_json::from_str(&action_json)
            .wrap_err("failed to construct action from JSON")?;

        // First get a client to check transaction status
        let url = tendermint_rpc::Url::from_str(&self.sequencer_url)
            .wrap_err("failed to parse sequencer URL")?;
        let _sequencer_client = HttpClient::new(url)
            .wrap_err("failed constructing http sequencer client")?;
            
        println\!("Submitting transaction to create order...");
        
        let hash = match submit_transaction(
            &self.sequencer_url,
            self.chain_id,
            &self.prefix,
            &self.private_key,
            action,
        )
        .await {
            Ok(response) => {
                println\!("Transaction submitted successfully\!");
                println\!("Transaction hash: {}", response.hash);
                println\!("Block height: {}", response.height);
                response.hash
            },
            Err(e) => {
                println\!("Transaction submission completed with error: {}", e);
                println\!("The transaction may still have been accepted.");
                println\!("Check the sequencer logs for more information.");
                return Err(e);
            }
        };
        
        // Try to query the transaction status
        println\!("You can query this transaction with:");
        println\!("curl -s '{}/tx?hash=0x{}' | jq", self.sequencer_url, hex::encode(hash.as_bytes()));

        Ok(())
    }
}

#[derive(Debug, clap::Args)]
struct CancelOrderCommand {
    /// Order ID to cancel
    order_id: String,
    /// Asset to pay fees in
    #[arg(long, default_value = "nria")]
    fee_asset: String,
    /// RPC endpoint
    #[arg(short, long, default_value = "http://localhost:26657")]
    sequencer_url: String,
    /// Chain ID
    #[arg(long, default_value = "astria")]
    chain_id: String,
    /// Prefix for addresses
    #[arg(long, default_value = "astria")]
    prefix: String,
    /// Private key (hex-encoded)
    #[arg(short, long, env = "ASTRIA_CLI_SEQUENCER_PRIVATE_KEY")]
    private_key: String,
}

impl CancelOrderCommand {
    async fn run(self) -> eyre::Result<()> {
        // Constructing the action JSON manually
        let action_json = format\!(
            r#"{{
                "cancelOrder": {{
                    "order_id": "{}",
                    "fee_asset": "{}"
                }}
            }}"#,
            self.order_id, self.fee_asset
        );

        let action: Action = serde_json::from_str(&action_json)
            .wrap_err("failed to construct action from JSON")?;

        // First get a client to check transaction status
        let url = tendermint_rpc::Url::from_str(&self.sequencer_url)
            .wrap_err("failed to parse sequencer URL")?;
        let _sequencer_client = HttpClient::new(url)
            .wrap_err("failed constructing http sequencer client")?;
            
        println\!("Submitting transaction to cancel order...");
        
        let hash = match submit_transaction(
            &self.sequencer_url,
            self.chain_id,
            &self.prefix,
            &self.private_key,
            action,
        )
        .await {
            Ok(response) => {
                println\!("Transaction submitted successfully\!");
                println\!("Transaction hash: {}", response.hash);
                println\!("Block height: {}", response.height);
                response.hash
            },
            Err(e) => {
                println\!("Transaction submission completed with error: {}", e);
                println\!("The transaction may still have been accepted.");
                println\!("Check the sequencer logs for more information.");
                return Err(e);
            }
        };
        
        // Try to query the transaction status
        println\!("You can query this transaction with:");
        println\!("curl -s '{}/tx?hash=0x{}' | jq", self.sequencer_url, hex::encode(hash.as_bytes()));

        Ok(())
    }
}

#[derive(Debug, clap::Args)]
struct GetMarketsCommand {
    /// The url of the Sequencer node
    #[arg(long, env = "SEQUENCER_URL", default_value = "http://localhost:26657")]
    sequencer_url: String,
}

impl GetMarketsCommand {
    async fn run(self) -> eyre::Result<()> {
        let url = tendermint_rpc::Url::from_str(&self.sequencer_url)
            .wrap_err("failed to parse sequencer URL")?;
        let sequencer_client = HttpClient::new(url)
            .wrap_err("failed constructing http sequencer client")?;
        
        println\!("Querying markets from sequencer at {}", self.sequencer_url);
        
        // Print the current version of the sequencer to check features
        let version_response = match sequencer_client.abci_info().await {
            Ok(info) => format\!("Sequencer version: {}, App version: {}", info.version, info.app_version),
            Err(e) => format\!("Failed to get sequencer version: {}", e),
        };
        println\!("{}", version_response);
        
        // First, try to get all component state to check if orderbook is available
        let components_response = sequencer_client
            .abci_query(Some("app/components".to_string()), vec\![], Some(0u32.into()), false)
            .await
            .wrap_err("failed to query app components")?;
        
        let components_str = String::from_utf8(components_response.value.to_vec())
            .wrap_err("failed to convert components response to string")?;
        
        println\!("Available components: {}", components_str);
        
        // Query the orderbook state
        println\!("Querying orderbook markets...");
        let response = sequencer_client
            .abci_query(Some("orderbook/markets".to_string()), vec\![], Some(0u32.into()), false)
            .await
            .wrap_err("failed to query markets")?;
        
        println\!("Got response - code: {:?}, log: {}", response.code, response.log);
        println\!("Response value size: {} bytes", response.value.len());
        
        // If response is empty
        if response.value.is_empty() {
            println\!("No markets found in response.");
            return Ok(());
        }
        
        // Try to parse as JSON first
        let raw_string = String::from_utf8_lossy(&response.value);
        println\!("Raw response: {}", raw_string);
        
        match serde_json::from_str::<Vec<String>>(&raw_string) {
            Ok(markets) => {
                if markets.is_empty() {
                    println\!("No markets found.");
                } else {
                    println\!("Markets found:");
                    for (i, market) in markets.iter().enumerate() {
                        println\!("{}. {}", i + 1, market);
                    }
                }
            },
            Err(_) => {
                // If JSON parsing fails, try splitting by delimiters
                println\!("Response is not in JSON format. Trying to parse manually...");
                
                // Try to parse potential market names
                let markets: Vec<&str> = raw_string
                    .split(|c: char| \!c.is_alphanumeric() && c \!= '-' && c \!= '/' && c \!= '_')
                    .filter(|s| \!s.is_empty() && s.len() > 2) // filter out very short segments
                    .collect();
                
                if \!markets.is_empty() {
                    println\!("Markets found:");
                    for (i, market) in markets.iter().enumerate() {
                        println\!("{}. {}", i + 1, market);
                    }
                } else {
                    println\!("No markets could be parsed from the response.");
                }
            }
        }
        
        Ok(())
    }
}

#[derive(Debug, clap::Args)]
struct GetOrdersCommand {
    /// Market identifier, e.g., BTC/USD
    market: String,
    /// Order side (buy or sell) - optional
    #[arg(long)]
    side: Option<String>,
    /// The url of the Sequencer node
    #[arg(long, env = "SEQUENCER_URL", default_value = "http://localhost:26657")]
    sequencer_url: String,
}

impl GetOrdersCommand {
    async fn run(self) -> eyre::Result<()> {
        let url = tendermint_rpc::Url::from_str(&self.sequencer_url)
            .wrap_err("failed to parse sequencer URL")?;
        let sequencer_client = HttpClient::new(url)
            .wrap_err("failed constructing http sequencer client")?;
        
        println\!("Querying orders for market {} from sequencer at {}", self.market, self.sequencer_url);
        
        // Try multiple paths to see which one works
        let possible_paths = vec\![
            format\!("orderbook/{}", self.market),
            format\!("orderbook/orders/market/{}/buy", self.market),
            format\!("orderbook/orders/market/{}/sell", self.market)
        ];
        
        let mut found_data = false;
        
        for path in &possible_paths {
            println\!("Trying path: {}", path);
            
            match sequencer_client.abci_query(Some(path.clone()), vec\![], Some(0u32.into()), false).await {
                Ok(response) => {
                    println\!("Got response - code: {:?}, log: {}", response.code, response.log);
                    println\!("Response value size: {} bytes", response.value.len());
                    
                    // If we got an OK response and the response has data, use it
                    if response.code.is_ok() && \!response.value.is_empty() {
                        println\!("Found a working query path: {}", path);
                        
                        // For now, just print the raw response since we can't easily deserialize it
                        let raw_string = String::from_utf8_lossy(&response.value);
                        println\!("Raw response: {}", raw_string);
                        println\!("Response bytes (first 50): {:?}", 
                            &response.value[0..std::cmp::min(50, response.value.len())]);
                        
                        // Try to extract some meaningful information from the response
                        // Look for uuid-like strings (order IDs) and other patterns
                        let potential_ids: Vec<&str> = raw_string
                            .split(|c: char| \!c.is_alphanumeric() && c \!= '-')
                            .filter(|s| 
                                \!s.is_empty() && 
                                (s.len() == 36 || // UUID length
                                (s.len() > 8 && s.contains('-'))) // Partial UUID or similar ID
                            )
                            .collect();
                        
                        if \!potential_ids.is_empty() {
                            println\!("\nPotential order IDs found:");
                            for (i, id) in potential_ids.iter().enumerate() {
                                if i < 10 { // Just show a few
                                    println\!("{}. {}", i + 1, id);
                                }
                            }
                            println\!("Found {} potential IDs in total", potential_ids.len());
                        } else {
                            println\!("No order IDs could be identified in the response.");
                        }
                        
                        found_data = true;
                        break;
                    }
                },
                Err(e) => {
                    println\!("Error querying {}: {}", path, e);
                }
            }
        }
        
        // If we get here and found_data is false, none of the paths worked
        if \!found_data {
            println\!("No orders found for market {}. None of the query paths returned valid data.", self.market);
        }
        
        Ok(())
    }
}
