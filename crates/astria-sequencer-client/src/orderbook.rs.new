//! Extension trait for interacting with the Astria Sequencer orderbook.
//!
//! This module provides types and methods for querying the orderbook API.

use async_trait::async_trait;
use borsh::{BorshDeserialize, BorshSerialize};
use prost::Message as _;
use serde::{Deserialize, Serialize};

use astria_core::{
    primitive::v1::Address,
    protocol::{
        orderbook::v1::{
            Order, OrderMatch, Orderbook, OrderSide, OrderType, OrderTimeInForce,
        },
    },
};

use crate::extension_trait::Error;

/// A wrapper around the sequencer's market parameters.
#[derive(Clone, Debug, Deserialize, Serialize, BorshSerialize, BorshDeserialize)]
pub struct MarketParams {
    /// The base asset for the market
    pub base_asset: String,
    /// The quote asset for the market
    pub quote_asset: String,
    /// The minimum price increment (tick size)
    pub tick_size: Option<u128>,
    /// The minimum quantity increment (lot size)
    pub lot_size: Option<u128>,
    /// Whether the market is paused
    pub paused: bool,
}

/// An aggregated view of the orderbook showing quantities at each price level.
#[derive(Clone, Debug, Deserialize, Serialize, BorshSerialize, BorshDeserialize)]
pub struct OrderbookDepth {
    /// The market identifier
    pub market: String,
    /// The bid levels (buy orders), sorted by price descending
    pub bids: Vec<OrderbookDepthLevel>,
    /// The ask levels (sell orders), sorted by price ascending
    pub asks: Vec<OrderbookDepthLevel>,
}

/// A single price level in the orderbook depth.
#[derive(Clone, Debug, Deserialize, Serialize, BorshSerialize, BorshDeserialize)]
pub struct OrderbookDepthLevel {
    /// The price level
    pub price: Option<u128>,
    /// The total quantity at this price level
    pub quantity: Option<u128>,
    /// The number of orders at this price level
    pub order_count: u32,
}

/// Errors that can occur when interacting with the orderbook API.
#[derive(Debug, thiserror::Error)]
pub enum OrderbookError {
    /// Error occurred when deserializing orderbook response
    #[error("failed to deserialize orderbook response: {0}")]
    Deserialization(#[source] borsh::io::Error),

    /// Error occurred when serializing orderbook request
    #[error("failed to serialize orderbook request: {0}")]
    Serialization(#[source] borsh::io::Error),

    /// Error occurred during the sequencer client request
    #[error("sequencer client request failed: {0}")]
    Client(#[source] crate::extension_trait::Error),

    /// The requested market does not exist
    #[error("market does not exist: {0}")]
    MarketNotFound(String),

    /// The requested order does not exist
    #[error("order not found: {0}")]
    OrderNotFound(String),
    
    /// Error when signing transaction
    #[error("failed to sign transaction: {0}")]
    SigningError(String),
    
    /// Error when submitting transaction
    #[error("failed to submit transaction: {0}")]
    SubmissionError(String),

    /// Other errors
    #[error("orderbook error: {0}")]
    Other(String),
}

/// Extension trait for accessing orderbook-related functionality.
#[async_trait]
pub trait OrderbookClientExt: crate::extension_trait::SequencerClientExt {
    /// Creates a new order in the orderbook.
    ///
    /// # Arguments
    ///
    /// * `market` - The market identifier (e.g., "BTC/USD")
    /// * `side` - The order side (buy or sell)
    /// * `order_type` - The order type (limit or market)
    /// * `price` - The limit price (required for limit orders)
    /// * `quantity` - The amount to buy or sell
    /// * `time_in_force` - The time in force parameter
    /// * `fee_asset` - The asset used to pay the transaction fee
    ///
    /// # Errors
    ///
    /// * If the transaction fails to be submitted
    /// * If the order parameters are invalid
    async fn create_order(
        &self,
        market: String,
        side: OrderSide,
        order_type: OrderType,
        price: Option<u128>,
        quantity: u128,
        time_in_force: OrderTimeInForce,
        fee_asset: String,
    ) -> Result<tendermint_rpc::endpoint::broadcast::tx_sync::Response, OrderbookError>;

    /// Cancels an existing order.
    ///
    /// # Arguments
    ///
    /// * `order_id` - The ID of the order to cancel
    /// * `fee_asset` - The asset used to pay the transaction fee
    ///
    /// # Errors
    ///
    /// * If the transaction fails to be submitted
    /// * If the order does not exist or is not owned by the sender
    async fn cancel_order(
        &self,
        order_id: String,
        fee_asset: String,
    ) -> Result<tendermint_rpc::endpoint::broadcast::tx_sync::Response, OrderbookError>;

    /// Creates a new market for trading.
    ///
    /// # Arguments
    ///
    /// * `market` - The market identifier (e.g., "BTC/USD")
    /// * `base_asset` - The base asset of the market (e.g., "BTC")
    /// * `quote_asset` - The quote asset of the market (e.g., "USD")
    /// * `tick_size` - The minimum price increment
    /// * `lot_size` - The minimum quantity increment
    /// * `fee_asset` - The asset used to pay the transaction fee
    ///
    /// # Errors
    ///
    /// * If the transaction fails to be submitted
    /// * If the market parameters are invalid
    /// * If the market already exists
    async fn create_market(
        &self,
        market: String,
        base_asset: String,
        quote_asset: String,
        tick_size: Option<u128>,
        lot_size: Option<u128>,
        fee_asset: String,
    ) -> Result<tendermint_rpc::endpoint::broadcast::tx_sync::Response, OrderbookError>;

    /// Updates an existing market's parameters.
    ///
    /// # Arguments
    ///
    /// * `market` - The market identifier
    /// * `tick_size` - The new minimum price increment (if provided)
    /// * `lot_size` - The new minimum quantity increment (if provided)
    /// * `paused` - Whether the market is paused
    /// * `fee_asset` - The asset used to pay the transaction fee
    ///
    /// # Errors
    ///
    /// * If the transaction fails to be submitted
    /// * If the market does not exist
    async fn update_market(
        &self,
        market: String,
        tick_size: Option<u128>,
        lot_size: Option<u128>,
        paused: bool,
        fee_asset: String,
    ) -> Result<tendermint_rpc::endpoint::broadcast::tx_sync::Response, OrderbookError>;
    /// Returns all available markets.
    ///
    /// # Errors
    ///
    /// - If calling the tendermint RPC fails
    /// - If the response cannot be deserialized
    async fn get_markets(&self) -> Result<Vec<String>, OrderbookError> {
        const PATH: &str = "orderbook/markets";

        let response = self
            .abci_query(Some(PATH.to_string()), vec![], None, false)
            .await
            .map_err(|e| OrderbookError::Client(Error::tendermint_rpc("abci_query", e)))?;

        // Parse the response as JSON
        let markets: Vec<String> = serde_json::from_slice(&response.value)
            .map_err(|_| OrderbookError::Other("Failed to parse markets response as JSON".to_string()))?;

        Ok(markets)
    }

    /// Returns the parameters for a specific market.
    ///
    /// # Errors
    ///
    /// - If calling the tendermint RPC fails
    /// - If the response cannot be deserialized
    /// - If the market does not exist
    async fn get_market_params(&self, market: &str) -> Result<MarketParams, OrderbookError> {
        let path = format!("orderbook/market_params/{}", market);

        let response = self
            .abci_query(Some(path), vec![], None, false)
            .await
            .map_err(|e| OrderbookError::Client(Error::tendermint_rpc("abci_query", e)))?;

        if response.code.is_err() {
            return Err(OrderbookError::MarketNotFound(market.to_string()));
        }

        // Deserialize the response using Borsh
        let params = borsh::from_slice::<MarketParams>(&response.value)
            .map_err(OrderbookError::Deserialization)?;

        Ok(params)
    }

    /// Returns the full orderbook for a specific market.
    ///
    /// # Errors
    ///
    /// - If calling the tendermint RPC fails
    /// - If the response cannot be deserialized
    /// - If the market does not exist
    async fn get_orderbook(&self, market: &str) -> Result<Orderbook, OrderbookError> {
        let path = format!("orderbook/{}", market);

        let response = self
            .abci_query(Some(path), vec![], None, false)
            .await
            .map_err(|e| OrderbookError::Client(Error::tendermint_rpc("abci_query", e)))?;

        if response.code.is_err() {
            return Err(OrderbookError::MarketNotFound(market.to_string()));
        }

        // Deserialize the response using Borsh
        let wrapper = borsh::from_slice::<OrderbookWrapper>(&response.value)
            .map_err(OrderbookError::Deserialization)?;

        Ok(wrapper.0)
    }

    /// Returns the orderbook depth (aggregated by price level) for a specific market.
    ///
    /// # Errors
    ///
    /// - If calling the tendermint RPC fails
    /// - If the response cannot be deserialized
    /// - If the market does not exist
    async fn get_orderbook_depth(&self, market: &str, levels: Option<usize>) -> Result<OrderbookDepth, OrderbookError> {
        let path = match levels {
            Some(l) => format!("orderbook/depth/{}/{}", market, l),
            None => format!("orderbook/depth/{}", market),
        };

        let response = self
            .abci_query(Some(path), vec![], None, false)
            .await
            .map_err(|e| OrderbookError::Client(Error::tendermint_rpc("abci_query", e)))?;

        if response.code.is_err() {
            return Err(OrderbookError::MarketNotFound(market.to_string()));
        }

        // Deserialize the response using Borsh
        let wrapper = borsh::from_slice::<OrderbookDepthWrapper>(&response.value)
            .map_err(OrderbookError::Deserialization)?;

        Ok(wrapper.0)
    }

    /// Returns a specific order by ID.
    ///
    /// # Errors
    ///
    /// - If calling the tendermint RPC fails
    /// - If the response cannot be deserialized
    /// - If the order does not exist
    async fn get_order(&self, order_id: &str) -> Result<Order, OrderbookError> {
        let path = format!("orderbook/order/{}", order_id);

        let response = self
            .abci_query(Some(path), vec![], None, false)
            .await
            .map_err(|e| OrderbookError::Client(Error::tendermint_rpc("abci_query", e)))?;

        if response.code.is_err() {
            return Err(OrderbookError::OrderNotFound(order_id.to_string()));
        }

        // Deserialize the response using Borsh
        let wrapper = borsh::from_slice::<OrderWrapper>(&response.value)
            .map_err(OrderbookError::Deserialization)?;

        Ok(wrapper.0)
    }

    /// Returns all orders for a specific market, optionally filtered by side.
    ///
    /// # Errors
    ///
    /// - If calling the tendermint RPC fails
    /// - If the response cannot be deserialized
    /// - If the market does not exist
    async fn get_market_orders(&self, market: &str, side: Option<OrderSide>) -> Result<Vec<Order>, OrderbookError> {
        let path = match side {
            Some(OrderSide::Buy) => format!("orderbook/orders/market/{}/buy", market),
            Some(OrderSide::Sell) => format!("orderbook/orders/market/{}/sell", market),
            _ => format!("orderbook/orders/market/{}", market),
        };

        let response = self
            .abci_query(Some(path), vec![], None, false)
            .await
            .map_err(|e| OrderbookError::Client(Error::tendermint_rpc("abci_query", e)))?;

        if response.code.is_err() {
            return Err(OrderbookError::MarketNotFound(market.to_string()));
        }

        // Deserialize the response using Borsh
        let wrappers = borsh::from_slice::<Vec<OrderWrapper>>(&response.value)
            .map_err(OrderbookError::Deserialization)?;

        Ok(wrappers.into_iter().map(|w| w.0).collect())
    }

    /// Returns all orders owned by a specific address.
    ///
    /// # Errors
    ///
    /// - If calling the tendermint RPC fails
    /// - If the response cannot be deserialized
    async fn get_owner_orders(&self, owner: Address) -> Result<Vec<Order>, OrderbookError> {
        let path = format!("orderbook/orders/owner/{}", owner);

        let response = self
            .abci_query(Some(path), vec![], None, false)
            .await
            .map_err(|e| OrderbookError::Client(Error::tendermint_rpc("abci_query", e)))?;

        // Deserialize the response using Borsh
        let wrappers = borsh::from_slice::<Vec<OrderWrapper>>(&response.value)
            .map_err(OrderbookError::Deserialization)?;

        Ok(wrappers.into_iter().map(|w| w.0).collect())
    }

    /// Returns recent trades for a specific market.
    ///
    /// # Errors
    ///
    /// - If calling the tendermint RPC fails
    /// - If the response cannot be deserialized
    /// - If the market does not exist
    async fn get_trades(&self, market: &str, limit: Option<usize>) -> Result<Vec<OrderMatch>, OrderbookError> {
        let path = match limit {
            Some(l) => format!("orderbook/trades/{}/{}", market, l),
            None => format!("orderbook/trades/{}/10", market), // Default limit is 10
        };

        let response = self
            .abci_query(Some(path), vec![], None, false)
            .await
            .map_err(|e| OrderbookError::Client(Error::tendermint_rpc("abci_query", e)))?;

        if response.code.is_err() {
            return Err(OrderbookError::MarketNotFound(market.to_string()));
        }

        // Deserialize the response using Borsh
        let wrappers = borsh::from_slice::<Vec<OrderMatchWrapper>>(&response.value)
            .map_err(OrderbookError::Deserialization)?;

        Ok(wrappers.into_iter().map(|w| w.0).collect())
    }
}

/// Implement the OrderbookClientExt trait for any type that implements the SequencerClientExt trait
#[async_trait]
impl<T: crate::extension_trait::SequencerClientExt + Sync> OrderbookClientExt for T {
    async fn create_order(
        &self,
        _market: String,
        _side: OrderSide,
        _order_type: OrderType,
        _price: Option<u128>,
        _quantity: u128,
        _time_in_force: OrderTimeInForce,
        _fee_asset: String,
    ) -> Result<tendermint_rpc::endpoint::broadcast::tx_sync::Response, OrderbookError> {
        // In a real implementation, this would:
        // 1. Create a CreateOrderAction with the given parameters
        // 2. Create a transaction body with the action
        // 3. Sign the transaction
        // 4. Submit the transaction
        
        // For now, we're just returning a placeholder error since the full implementation
        // would require adding methods to the SequencerClientExt trait
        Err(OrderbookError::Other("Transaction submission not yet implemented".to_string()))
    }

    async fn cancel_order(
        &self,
        _order_id: String,
        _fee_asset: String,
    ) -> Result<tendermint_rpc::endpoint::broadcast::tx_sync::Response, OrderbookError> {
        // In a real implementation, this would:
        // 1. Create a CancelOrderAction with the given parameters
        // 2. Create a transaction body with the action
        // 3. Sign the transaction
        // 4. Submit the transaction
        
        // For now, we're just returning a placeholder error since the full implementation
        // would require adding methods to the SequencerClientExt trait
        Err(OrderbookError::Other("Transaction submission not yet implemented".to_string()))
    }

    async fn create_market(
        &self,
        _market: String,
        _base_asset: String,
        _quote_asset: String,
        _tick_size: Option<u128>,
        _lot_size: Option<u128>,
        _fee_asset: String,
    ) -> Result<tendermint_rpc::endpoint::broadcast::tx_sync::Response, OrderbookError> {
        // In a real implementation, this would:
        // 1. Create a CreateMarketAction with the given parameters
        // 2. Create a transaction body with the action
        // 3. Sign the transaction
        // 4. Submit the transaction
        
        // For now, we're just returning a placeholder error since the full implementation
        // would require adding methods to the SequencerClientExt trait
        Err(OrderbookError::Other("Transaction submission not yet implemented".to_string()))
    }

    async fn update_market(
        &self,
        _market: String,
        _tick_size: Option<u128>,
        _lot_size: Option<u128>,
        _paused: bool,
        _fee_asset: String,
    ) -> Result<tendermint_rpc::endpoint::broadcast::tx_sync::Response, OrderbookError> {
        // In a real implementation, this would:
        // 1. Create a UpdateMarketAction with the given parameters
        // 2. Create a transaction body with the action
        // 3. Sign the transaction
        // 4. Submit the transaction
        
        // For now, we're just returning a placeholder error since the full implementation
        // would require adding methods to the SequencerClientExt trait
        Err(OrderbookError::Other("Transaction submission not yet implemented".to_string()))
    }
}

// Wrapper types for Borsh serialization/deserialization
// These are similar to those in the sequencer crate

/// Wrapper for Order
#[derive(Debug)]
struct OrderWrapper(Order);

impl borsh::BorshSerialize for OrderWrapper {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        let bytes = self.0.encode_to_vec();
        borsh::BorshSerialize::serialize(&bytes, writer)
    }
}

impl borsh::BorshDeserialize for OrderWrapper {
    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> std::io::Result<Self> {
        let bytes: Vec<u8> = borsh::BorshDeserialize::deserialize_reader(reader)?;
        Order::decode(&*bytes)
            .map(OrderWrapper)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))
    }
}

/// Wrapper for OrderMatch
#[derive(Debug)]
struct OrderMatchWrapper(OrderMatch);

impl borsh::BorshSerialize for OrderMatchWrapper {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        let bytes = self.0.encode_to_vec();
        borsh::BorshSerialize::serialize(&bytes, writer)
    }
}

impl borsh::BorshDeserialize for OrderMatchWrapper {
    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> std::io::Result<Self> {
        let bytes: Vec<u8> = borsh::BorshDeserialize::deserialize_reader(reader)?;
        OrderMatch::decode(&*bytes)
            .map(OrderMatchWrapper)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))
    }
}

/// Wrapper for Orderbook
#[derive(Debug)]
struct OrderbookWrapper(Orderbook);

impl borsh::BorshSerialize for OrderbookWrapper {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        let bytes = self.0.encode_to_vec();
        borsh::BorshSerialize::serialize(&bytes, writer)
    }
}

impl borsh::BorshDeserialize for OrderbookWrapper {
    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> std::io::Result<Self> {
        let bytes: Vec<u8> = borsh::BorshDeserialize::deserialize_reader(reader)?;
        Orderbook::decode(&*bytes)
            .map(OrderbookWrapper)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))
    }
}

/// Wrapper for OrderbookDepth
#[derive(Debug)]
struct OrderbookDepthWrapper(OrderbookDepth);

impl borsh::BorshSerialize for OrderbookDepthWrapper {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        borsh::BorshSerialize::serialize(&self.0, writer)
    }
}

impl borsh::BorshDeserialize for OrderbookDepthWrapper {
    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> std::io::Result<Self> {
        let depth = OrderbookDepth::deserialize_reader(reader)?;
        Ok(OrderbookDepthWrapper(depth))
    }
}