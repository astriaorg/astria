// This file is @generated by prost-build.
/// A JSON-encoded form of this message is used as the upgrades file for the Sequencer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrades {
    #[prost(message, optional, tag = "1")]
    pub aspen: ::core::option::Option<Aspen>,
    #[prost(message, optional, tag = "2")]
    pub blackburn: ::core::option::Option<Blackburn>,
}
impl ::prost::Name for Upgrades {
    const NAME: &'static str = "Upgrades";
    const PACKAGE: &'static str = "astria.upgrades.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "astria.upgrades.v1.Upgrades".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/astria.upgrades.v1.Upgrades".into()
    }
}
/// Info specific to a given upgrade.
///
/// All upgrades have this info at a minimum.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BaseUpgradeInfo {
    /// The upgrade should be applied during the lifecycle of the block at this height.
    #[prost(uint64, tag = "1")]
    pub activation_height: u64,
    /// The app version running after the upgrade is applied.
    #[prost(uint64, tag = "2")]
    pub app_version: u64,
}
impl ::prost::Name for BaseUpgradeInfo {
    const NAME: &'static str = "BaseUpgradeInfo";
    const PACKAGE: &'static str = "astria.upgrades.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "astria.upgrades.v1.BaseUpgradeInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/astria.upgrades.v1.BaseUpgradeInfo".into()
    }
}
/// Aspen upgrade of the Sequencer network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aspen {
    #[prost(message, optional, tag = "1")]
    pub base_info: ::core::option::Option<BaseUpgradeInfo>,
    #[prost(message, optional, tag = "2")]
    pub price_feed_change: ::core::option::Option<aspen::PriceFeedChange>,
    #[prost(message, optional, tag = "3")]
    pub validator_update_action_change: ::core::option::Option<
        aspen::ValidatorUpdateActionChange,
    >,
    #[prost(message, optional, tag = "4")]
    pub ibc_acknowledgement_failure_change: ::core::option::Option<
        aspen::IbcAcknowledgementFailureChange,
    >,
}
/// Nested message and enum types in `Aspen`.
pub mod aspen {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PriceFeedChange {
        /// The price feed market map genesis data.
        #[prost(message, optional, tag = "1")]
        pub market_map_genesis: ::core::option::Option<
            super::super::super::super::connect::marketmap::v2::GenesisState,
        >,
        /// The price feed oracle genesis data.
        #[prost(message, optional, tag = "2")]
        pub oracle_genesis: ::core::option::Option<
            super::super::super::super::connect::oracle::v2::GenesisState,
        >,
    }
    impl ::prost::Name for PriceFeedChange {
        const NAME: &'static str = "PriceFeedChange";
        const PACKAGE: &'static str = "astria.upgrades.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "astria.upgrades.v1.Aspen.PriceFeedChange".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/astria.upgrades.v1.Aspen.PriceFeedChange".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ValidatorUpdateActionChange {}
    impl ::prost::Name for ValidatorUpdateActionChange {
        const NAME: &'static str = "ValidatorUpdateActionChange";
        const PACKAGE: &'static str = "astria.upgrades.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "astria.upgrades.v1.Aspen.ValidatorUpdateActionChange".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/astria.upgrades.v1.Aspen.ValidatorUpdateActionChange".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct IbcAcknowledgementFailureChange {}
    impl ::prost::Name for IbcAcknowledgementFailureChange {
        const NAME: &'static str = "IbcAcknowledgementFailureChange";
        const PACKAGE: &'static str = "astria.upgrades.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "astria.upgrades.v1.Aspen.IbcAcknowledgementFailureChange".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/astria.upgrades.v1.Aspen.IbcAcknowledgementFailureChange".into()
        }
    }
}
impl ::prost::Name for Aspen {
    const NAME: &'static str = "Aspen";
    const PACKAGE: &'static str = "astria.upgrades.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "astria.upgrades.v1.Aspen".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/astria.upgrades.v1.Aspen".into()
    }
}
/// Blackburn upgrade of the Sequencer network.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Blackburn {
    #[prost(message, optional, tag = "1")]
    pub base_info: ::core::option::Option<BaseUpgradeInfo>,
    #[prost(message, optional, tag = "2")]
    pub ics20_transfer_action_change: ::core::option::Option<
        blackburn::Ics20TransferActionChange,
    >,
    #[prost(message, optional, tag = "3")]
    pub allow_ibc_relay_to_fail: ::core::option::Option<blackburn::AllowIbcRelayToFail>,
    #[prost(message, optional, tag = "4")]
    pub disableable_bridge_account_deposits: ::core::option::Option<
        blackburn::DisableableBridgeAccountDeposits,
    >,
}
/// Nested message and enum types in `Blackburn`.
pub mod blackburn {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Ics20TransferActionChange {}
    impl ::prost::Name for Ics20TransferActionChange {
        const NAME: &'static str = "Ics20TransferActionChange";
        const PACKAGE: &'static str = "astria.upgrades.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "astria.upgrades.v1.Blackburn.Ics20TransferActionChange".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/astria.upgrades.v1.Blackburn.Ics20TransferActionChange".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AllowIbcRelayToFail {}
    impl ::prost::Name for AllowIbcRelayToFail {
        const NAME: &'static str = "AllowIbcRelayToFail";
        const PACKAGE: &'static str = "astria.upgrades.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "astria.upgrades.v1.Blackburn.AllowIbcRelayToFail".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/astria.upgrades.v1.Blackburn.AllowIbcRelayToFail".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DisableableBridgeAccountDeposits {}
    impl ::prost::Name for DisableableBridgeAccountDeposits {
        const NAME: &'static str = "DisableableBridgeAccountDeposits";
        const PACKAGE: &'static str = "astria.upgrades.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "astria.upgrades.v1.Blackburn.DisableableBridgeAccountDeposits".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/astria.upgrades.v1.Blackburn.DisableableBridgeAccountDeposits".into()
        }
    }
}
impl ::prost::Name for Blackburn {
    const NAME: &'static str = "Blackburn";
    const PACKAGE: &'static str = "astria.upgrades.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "astria.upgrades.v1.Blackburn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/astria.upgrades.v1.Blackburn".into()
    }
}
