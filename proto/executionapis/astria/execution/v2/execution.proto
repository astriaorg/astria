syntax = 'proto3';

package astria.execution.v2;

import "astria/primitive/v1/types.proto";
import "astria/sequencerblock/v1/block.proto";
import "google/protobuf/timestamp.proto";

// SequencerInfo contains the information needed to map sequencer block height
// to rollup block number for driving execution.
//
// This information is used to determine which sequencer & celestia data to
// use from the Astria & Celestia networks, as well as define shutdown/restart
// behavior of the Conductor.
message SequencerInfo {
  // The rollup_id is the unique identifier for the rollup chain.
  astria.primitive.v1.RollupId rollup_id = 1;
  // The first rollup block number to be executed. This is mapped to `sequencer_first_block_height`.
  // The minimum first block number is 1.
  uint64 rollup_first_block_number = 2;
  // The final rollup block number to execute before either re-fetching sequencer
  // info (restarting) or shutting down (determined by `halt_at_rollup_stop_number`).
  // If 0, no stop block will be set.
  uint64 rollup_stop_block_number = 3;
  // Requests that Conductor halt at `rollup_stop_block_number` instead of re-fetching
  // the sequencer info and continuing execution. This is a no-op if `rollup_stop_block_number`
  // is set to 0.
  bool rollup_halt_at_stop_number = 4;
  // The ID of the Astria Sequencer network to retrieve Sequencer blocks from.
  // Conductor implementations should verify that the Sequencer network they are
  // connected to have this chain ID (if fetching soft Sequencer blocks), and verify
  // that the Sequencer metadata blobs retrieved from Celestia contain this chain
  // ID (if extracting firm Sequencer blocks from Celestia blobs).
  string sequencer_chain_id = 5;
  // The first block height on the sequencer chain to use for rollup transactions.
  // This is mapped to `rollup_first_block_number`.
  uint64 sequencer_first_block_height = 6;
  // The ID of the Celestia network to retrieve blobs from.
  // Conductor implementations should verify that the Celestia network they are
  // connected to have this chain ID (if extracting firm Sequencer blocks from
  // Celestia blobs).
  string celestia_chain_id = 7;
  // The allowed variance in celestia for sequencer blocks to have been posted.
  uint64 celestia_block_variance = 8;
}

// The set of information which deterministic driver of block production
// must know about a given rollup Block
message Block {
  // The block number
  uint64 number = 1;
  // The hash of the block
  bytes hash = 2;
  // The hash from the parent block
  bytes parent_block_hash = 3;
  // Timestamp on the block, standardized to google protobuf standard.
  google.protobuf.Timestamp timestamp = 4;
}

// Fields which are indexed for finding blocks on a blockchain.
message BlockIdentifier {
  oneof identifier {
    uint64 number = 1;
    bytes hash = 2;
  }
}

// Used to fetch the current `SequencerInfo` from the rollup.
message GetSequencerInfoRequest {
  // The commitment type that the sequencer info is being fetched for. If the commitment
  // type is soft, the returned sequencer info should be based on the rollup's
  // soft commitment height. If the commitment type is firm, the returned sequencer
  // info should be based on the rollup's firm commitment height.
  CommitmentType commitment_type = 1;
}

// Used in `GetSequencerInfoRequest` to obtain the corresponding sequencer info
// for the rollup block number with the given commitment type.
enum CommitmentType {
  COMMITMENT_TYPE_UNSPECIFIED = 0;
  COMMITMENT_TYPE_SOFT = 1;
  COMMITMENT_TYPE_FIRM = 2;
}

// Used in GetBlock to find a single block.
message GetBlockRequest {
  BlockIdentifier identifier = 1;
}

// Used in BatchGetBlocks, will find all or none based on the list of
// identifiers.
message BatchGetBlocksRequest {
  repeated BlockIdentifier identifiers = 1;
}

// The list of blocks in response to BatchGetBlocks.
message BatchGetBlocksResponse {
  repeated Block blocks = 1;
}

// ExecuteBlockRequest contains all the information needed to create a new rollup
// block.
//
// This information comes from previous rollup blocks, as well as from sequencer
// blocks.
message ExecuteBlockRequest {
  // The hash of previous block, which new block will be created on top of.
  bytes prev_block_hash = 1;
  // List of transactions to include in the new block.
  repeated astria.sequencerblock.v1.RollupData transactions = 2;
  // Timestamp to be used for new block.
  google.protobuf.Timestamp timestamp = 3;
}

// The CommitmentState holds the block at each stage of sequencer commitment
// level
//
// A Valid CommitmentState:
// - Block numbers are such that soft >= firm.
// - No blocks ever decrease in block number.
// - The chain defined by soft is the head of the canonical chain the firm block
//   must belong to.
message CommitmentState {
  // Soft commitment is the rollup block matching latest sequencer block.
  Block soft = 1;
  // Firm commitment is achieved when data has been seen in DA.
  Block firm = 2;
  // The lowest block number of celestia chain to be searched for rollup blocks
  // given current state
  uint64 base_celestia_height = 3;
}

// There is only one CommitmentState object, so the request is empty.
message GetCommitmentStateRequest {}

// The CommitmentState to set, must include complete state.
message UpdateCommitmentStateRequest {
  CommitmentState commitment_state = 1;
}

// ExecutionService is used to drive deterministic production of blocks.
//
// The service can be implemented by any blockchain which wants to utilize the
// Astria Shared Sequencer, and will have block production driven via the Astria
// "Conductor".
service ExecutionService {
  // GetSequencerInfo returns the necessary information for mapping sequencer block
  // height to rollup block number.
  rpc GetSequencerInfo(GetSequencerInfoRequest) returns (SequencerInfo);

  // GetBlock will return a block given an identifier.
  rpc GetBlock(GetBlockRequest) returns (Block);

  // BatchGetBlocks will return an array of Blocks given an array of block
  // identifiers.
  rpc BatchGetBlocks(BatchGetBlocksRequest) returns (BatchGetBlocksResponse);

  // ExecuteBlock is called to deterministically derive a rollup block from
  // filtered sequencer block information.
  rpc ExecuteBlock(ExecuteBlockRequest) returns (Block);

  // GetCommitmentState fetches the current CommitmentState of the chain.
  rpc GetCommitmentState(GetCommitmentStateRequest) returns (CommitmentState);

  // UpdateCommitmentState replaces the whole CommitmentState with a new
  // CommitmentState.
  rpc UpdateCommitmentState(UpdateCommitmentStateRequest) returns (CommitmentState);
}
