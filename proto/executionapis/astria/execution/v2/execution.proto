syntax = 'proto3';

package astria.execution.v2;

import "astria/primitive/v1/types.proto";
import "astria/sequencerblock/v1/block.proto";
import "google/protobuf/timestamp.proto";

// Used in `GetSequencerInfoRequest` to obtain the corresponding sequencer info
// for the rollup block number with the given commitment type.
enum CommitmentType {
  COMMITMENT_TYPE_UNSPECIFIED = 0;
  COMMITMENT_TYPE_SOFT = 1;
  COMMITMENT_TYPE_FIRM = 2;
}

// ExecutionConfig contains the information needed to map sequencer block height
// to rollup block number for driving execution.
//
// This information is used to determine which sequencer & celestia data to
// use from the Astria & Celestia networks, as well as define shutdown/restart
// behavior of the Conductor.
message ExecutionConfig {
  // The rollup_id is the unique identifier for the rollup chain.
  astria.primitive.v1.RollupId rollup_id = 1;
  // The first rollup block number to be executed. This is mapped to `sequencer_first_block_height`.
  // The minimum first block number is 1.
  uint64 rollup_first_block_number = 2;
  // The final rollup block number to execute before either re-fetching sequencer
  // info (restarting) or shutting down (determined by `halt_at_rollup_stop_number`).
  // If 0, no stop block will be set.
  uint64 rollup_stop_block_number = 3;
  // The ID of the Astria Sequencer network to retrieve Sequencer blocks from.
  // Conductor implementations should verify that the Sequencer network they are
  // connected to have this chain ID (if fetching soft Sequencer blocks), and verify
  // that the Sequencer metadata blobs retrieved from Celestia contain this chain
  // ID (if extracting firm Sequencer blocks from Celestia blobs).
  string sequencer_chain_id = 4;
  // The first block height on the sequencer chain to use for rollup transactions.
  // This is mapped to `rollup_first_block_number`.
  uint64 sequencer_first_block_height = 5;
  // The ID of the Celestia network to retrieve blobs from.
  // Conductor implementations should verify that the Celestia network they are
  // connected to have this chain ID (if extracting firm Sequencer blocks from
  // Celestia blobs).
  string celestia_chain_id = 6;
  // The allowed variance in celestia for sequencer blocks to have been posted.
  uint64 celestia_block_variance = 7;
}

// NewExecutionSessionRequest is used to create a new execution session on the
// rollup.
message NewExecutionSessionRequest {
  CommitmentType execution_level = 1;
}

// ExecutionSession contains the information needed to drive the full execution
// of a rollup chain in the rollup.
//
// The execution session is only valid for the execution config params with
// which it was created. Once all blocks within the session have been executed,
// the execution client must request a new session. The session_id is used to
// to track which session is being used.
message ExecutionSession {
  // A UUID for the session.
  string session_id = 1;
  // The commitment state for executing client to start from.
  CommitmentState commitment_state = 2;
  // The configuration for the execution session.
  ExecutionConfig execution_config = 3;
}

// The set of information which deterministic driver of block production
// must know about a given rollup Block
message Block {
  // The block number
  uint64 number = 1;
  // The hash of the block
  bytes hash = 2;
  // The hash from the parent block
  bytes parent_block_hash = 3;
  // Timestamp on the block, standardized to google protobuf standard.
  google.protobuf.Timestamp timestamp = 4;
}

// Fields which are indexed for finding blocks on a blockchain.
message BlockIdentifier {
  oneof identifier {
    uint64 number = 1;
    bytes hash = 2;
  }
}

// Used in GetBlock to find a single block.
message GetBlockRequest {
  BlockIdentifier identifier = 1;
}

// ExecuteBlockRequest contains all the information needed to create a new rollup
// block.
//
// This information comes from previous rollup blocks, as well as from sequencer
// blocks.
message ExecuteBlockRequest {
  // The session within which the block is intended to be executed.
  string session_id = 1;
  // The hash of previous block, which new block will be created on top of.
  bytes prev_block_hash = 2;
  // List of transactions to include in the new block.
  repeated astria.sequencerblock.v1.RollupData transactions = 3;
  // Timestamp to be used for new block.
  google.protobuf.Timestamp timestamp = 4;
}

// The CommitmentState holds the block at each stage of sequencer commitment
// level
//
// A Valid CommitmentState:
// - Block numbers are such that soft >= firm.
// - No blocks ever decrease in block number.
// - The chain defined by soft is the head of the canonical chain the firm block
//   must belong to.
message CommitmentState {
  // Soft commitment is the rollup block matching latest sequencer block.
  Block soft = 1;
  // Firm commitment is achieved when data has been seen in DA.
  Block firm = 2;
  // The lowest block number of celestia chain to be searched for rollup blocks
  // given current state
  uint64 base_celestia_height = 3;
}

// There is only one CommitmentState object, so the request is empty.
message GetCommitmentStateRequest {}

// The CommitmentState to set, must include complete state.
message UpdateCommitmentStateRequest {
  // The session which the commitment state is being updated within.
  string session_id = 1;
  // The new commitment state to set.
  CommitmentState commitment_state = 2;
}

// ExecutionService is used to drive deterministic production of blocks.
//
// The service can be implemented by any blockchain which wants to utilize the
// Astria Shared Sequencer, and will have block production driven via the Astria
// "Conductor".
service ExecutionService {
  // GetSequencerInfo returns the necessary information for mapping sequencer block
  // height to rollup block number.
  rpc NewExecutionSession(NewExecutionSessionRequest) returns (ExecutionSession);

  // GetBlock will return a block given an identifier.
  rpc GetBlock(GetBlockRequest) returns (Block);

  // ExecuteBlock is called to deterministically derive a rollup block from
  // filtered sequencer block information.
  rpc ExecuteBlock(ExecuteBlockRequest) returns (Block);

  // GetCommitmentState fetches the current CommitmentState of the chain.
  rpc GetCommitmentState(GetCommitmentStateRequest) returns (CommitmentState);

  // UpdateCommitmentState replaces the whole CommitmentState with a new
  // CommitmentState.
  rpc UpdateCommitmentState(UpdateCommitmentStateRequest) returns (CommitmentState);
}
